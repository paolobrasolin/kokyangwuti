<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Web Weaver: Parallel Physics</title>
  <style>
    :root {
      --bg-color: #050510;
      --text-color: #a0a0ff;
      --ui-bg: rgba(10, 10, 30, 0.9);
      --accent: #00f3ff;
      --secondary: #ff0055;
      --success: #00ff88;
    }

    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: var(--bg-color);
      font-family: 'Courier New', Courier, monospace;
      color: var(--text-color);
      touch-action: none;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    #ui-layer {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 300px;
      background: var(--ui-bg);
      padding: 20px;
      border-radius: 8px;
      border: 1px solid rgba(160, 160, 255, 0.2);
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
      max-height: 90vh;
      overflow-y: auto;
      pointer-events: none;
    }

    #ui-layer * {
      pointer-events: auto;
    }

    h1 {
      font-size: 14px;
      margin: 0 0 10px 0;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 2px;
      display: flex;
      justify-content: space-between;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-size: 11px;
    }

    .stat-label {
      color: #8888aa;
    }

    .stat-val {
      color: #fff;
      font-weight: bold;
    }

    .highlight {
      color: var(--success);
    }

    .danger {
      color: var(--secondary);
    }

    .bar-container {
      width: 100%;
      height: 6px;
      background: #222;
      margin: 5px 0 15px 0;
      border-radius: 3px;
      overflow: hidden;
    }

    .bar-fill {
      height: 100%;
      background: var(--accent);
      width: 100%;
      transition: width 0.2s, background 0.2s;
    }

    #log-console {
      margin-top: 10px;
      height: 80px;
      overflow: hidden;
      font-size: 10px;
      color: #55ff55;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      padding-top: 10px;
      opacity: 0.8;
      font-family: monospace;
    }

    .log-entry {
      margin-bottom: 3px;
    }

    .dna-display {
      border: 1px solid #333;
      padding: 8px;
      margin-bottom: 10px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
    }

    .dna-title {
      font-size: 10px;
      color: var(--accent);
      margin-bottom: 4px;
      border-bottom: 1px solid #333;
      display: block;
    }

    .control-group {
      margin-bottom: 10px;
    }

    label {
      display: block;
      font-size: 10px;
      color: #8888aa;
      margin-bottom: 2px;
    }

    input[type="range"] {
      width: 100%;
      background: transparent;
      -webkit-appearance: none;
      margin: 5px 0;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 12px;
      width: 12px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      margin-top: -4px;
    }

    input[type="range"]::-webkit-slider-runnable-track {
      width: 100%;
      height: 4px;
      background: #333;
      border-radius: 2px;
    }

    button {
      width: 100%;
      padding: 8px;
      background: rgba(0, 243, 255, 0.1);
      border: 1px solid var(--accent);
      color: var(--accent);
      font-family: inherit;
      font-weight: bold;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 11px;
      margin-bottom: 5px;
    }

    button:hover {
      background: var(--accent);
      color: var(--bg-color);
    }

    #toggle-ui {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      background: var(--ui-bg);
      border: 1px solid var(--accent);
      color: var(--accent);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
    }
  </style>
</head>

<body>
  <div id="ui-layer">
    <h1><span>AI.Swarm.Parallel</span><span id="gen-counter">GEN 1</span></h1>

    <div class="stat-row"><span class="stat-label">Time Remaining:</span><span id="timer-text"
        class="stat-val">--</span></div>
    <div class="stat-row"><span class="stat-label">Active Agents:</span><span id="pop-count" class="stat-val">0</span>
    </div>
    <div class="stat-row" style="margin-top: 10px;"><span class="stat-label">Avg Efficiency:</span><span id="energy-val"
        class="stat-val">100%</span></div>
    <div class="bar-container">
      <div id="energy-bar" class="bar-fill"></div>
    </div>

    <div class="dna-display">
      <span class="dna-title">BEHAVIORAL GENOME (ANCESTOR)</span>
      <div class="stat-row"><span class="stat-label">Drop Rate:</span> <span id="dna-drop" class="stat-val">--</span>
      </div>
      <div class="stat-row"><span class="stat-label">Glide Factor:</span> <span id="dna-speed"
          class="stat-val">--</span></div>
      <div class="stat-row"><span class="stat-label">Vertical Bias:</span> <span id="dna-bias"
          class="stat-val">--</span></div>
    </div>

    <div class="control-group">
      <label>Population Size</label>
      <input type="range" id="pop-input" min="1" max="50" value="8" step="1">
    </div>
    <div class="control-group">
      <label>Fly Rate (Z-Axis Traffic)</label>
      <input type="range" id="food-input" min="0" max="200" value="50" step="1">
    </div>

    <button id="speed-btn">Speed: 1x</button>
    <div class="stat-row"><span class="stat-label">Max Fitness:</span><span id="best-fitness"
        class="stat-val highlight">0.0</span></div>
    <div id="log-console"></div>
  </div>

  <button id="toggle-ui" title="Toggle UI">_</button>
  <canvas id="sim-canvas"></canvas>

  <script>
    // --- Constants & Config ---
    const STARTING_ENERGY = 2000;
    const COST_CRAWL = 0.05;
    const COST_DROP_START = 20;
    const COST_DROP_PIXEL = 0.2;
    const GAIN_FLY = 1000;
    const GEN_DURATION_MS = 60000;

    // --- Globals ---
    const canvas = document.getElementById('sim-canvas');
    const ctx = canvas.getContext('2d');
    const ui = {
      gen: document.getElementById('gen-counter'),
      timer: document.getElementById('timer-text'),
      pop: document.getElementById('pop-count'),
      bar: document.getElementById('energy-bar'),
      val: document.getElementById('energy-val'),
      dnaDrop: document.getElementById('dna-drop'),
      dnaSpeed: document.getElementById('dna-speed'),
      dnaBias: document.getElementById('dna-bias'),
      bestFit: document.getElementById('best-fitness'),
      popInput: document.getElementById('pop-input'),
      food: document.getElementById('food-input'),
      speedBtn: document.getElementById('speed-btn'),
      log: document.getElementById('log-console'),
      uiLayer: document.getElementById('ui-layer')
    };

    let simSpeed = 1;
    let flyRate = 0.1; // Probability of fly appearing per frame
    let targetPopulation = 8;
    let globalTime = 0;

    // --- State ---
    let evolution = {
      generation: 1,
      bestFitness: -Infinity,
      bestGenome: {
        dropRate: 0.015,
        glide: 0.5,
        speed: 1.0,
        bias: 0.35
      }
    };

    let state = {
      active: true,
      genTimer: 0,
      width: 0, height: 0,
      frameLines: [], // Shared boundary
      agents: []
    };

    // --- Init ---
    function init() {
      resize();
      window.addEventListener('resize', resize);
      ui.speedBtn.addEventListener('click', () => {
        if (simSpeed === 1) simSpeed = 5;
        else if (simSpeed === 5) simSpeed = 20;
        else if (simSpeed === 20) simSpeed = 100;
        else if (simSpeed === 100) simSpeed = 1000;
        else if (simSpeed === 1000) simSpeed = 10000;
        else simSpeed = 1;
        ui.speedBtn.textContent = `Speed: ${simSpeed}x`;
      });
      ui.popInput.addEventListener('input', e => targetPopulation = parseInt(e.target.value));
      ui.food.addEventListener('input', e => flyRate = e.target.value / 200);
      document.getElementById('toggle-ui').addEventListener('click', () => {
        ui.uiLayer.style.opacity = ui.uiLayer.style.opacity === '0' ? '1' : '0';
      });

      startGeneration();
      requestAnimationFrame(loop);
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      state.width = canvas.width;
      state.height = canvas.height;
    }

    function log(msg, type = '') {
      const div = document.createElement('div');
      div.className = `log-entry ${type}`;
      div.textContent = `> ${msg}`;
      ui.log.prepend(div);
      if (ui.log.children.length > 6) ui.log.lastChild.remove();
    }

    // --- Core Simulation ---

    function startGeneration() {
      state.genTimer = 0;
      state.active = true;

      // Build Shared Frame
      const w = state.width, h = state.height;
      const frameColor = 'rgba(50,50,80,0.3)';
      state.frameLines = [
        {x1: 0, y1: 0, x2: w, y2: 0, id: 0, color: frameColor}, // Top
        {x1: w, y1: 0, x2: w, y2: h, id: 1, color: frameColor}, // Right
        {x1: w, y1: h, x2: 0, y2: h, id: 2, color: frameColor}, // Bottom
        {x1: 0, y1: h, x2: 0, y2: 0, id: 3, color: frameColor}  // Left
      ];

      // Agents
      state.agents = [];
      for (let i = 0; i < targetPopulation; i++) {
        let genome = mutate(evolution.bestGenome);
        state.agents.push(createAgent(i, genome));
      }

      ui.gen.textContent = `GEN ${evolution.generation}`;
      ui.dnaDrop.textContent = evolution.bestGenome.dropRate.toFixed(3);
      ui.dnaSpeed.textContent = evolution.bestGenome.glide.toFixed(2);
      ui.dnaBias.textContent = evolution.bestGenome.bias.toFixed(2);
      log(`Gen ${evolution.generation} Started`);
    }

    function mutate(g) {
      let n = {...g};
      if (Math.random() < 0.4) n.dropRate = Math.max(0.001, Math.min(0.1, n.dropRate + (Math.random() - 0.5) * 0.01));
      if (Math.random() < 0.4) n.glide = Math.max(0.0, Math.min(5.0, n.glide + (Math.random() - 0.5) * 0.5));
      if (Math.random() < 0.4) n.speed = Math.max(0.5, Math.min(3.0, n.speed + (Math.random() - 0.5) * 0.2));
      if (Math.random() < 0.4) n.bias = Math.max(0.0, Math.min(1.0, n.bias + (Math.random() - 0.5) * 0.2));
      return n;
    }

    function createAgent(id, genome) {
      const startX = Math.random() * state.width;
      const hue = Math.random() * 360;
      return {
        id: id,
        genome: genome,
        alive: true,
        energy: STARTING_ENERGY,
        score: 0,
        // Physics State
        x: startX,
        y: 0,
        state: 'crawling', // 'crawling', 'falling'
        // Crawling State
        currentLineIdx: 0,
        t: startX / state.width,
        direction: Math.random() < 0.5 ? 1 : -1,
        // Falling/Gliding State
        dropStartPos: null,
        vx: 0,
        vy: 0,
        // Private World
        lines: [], // Own web lines
        fliesCaught: [], // Visual record of flies caught on own web
        // Visuals
        color: `hsl(${hue}, 100%, 60%)`,
        webColor: `hsla(${hue}, 100%, 70%, 0.4)`,
        legPhase: Math.random() * 10
      };
    }

    function endGeneration() {
      state.active = false;
      let best = null;
      let maxFit = -Infinity;
      state.agents.forEach(a => {
        let fit = a.energy + (a.score * 1500);
        if (!a.alive) fit = -1000 + (a.score * 500);
        if (fit > maxFit) {maxFit = fit; best = a;}
      });

      if (best && maxFit > -500) {
        if (maxFit > evolution.bestFitness) {
          evolution.bestFitness = maxFit;
          ui.bestFit.textContent = maxFit.toFixed(0);
          log("New Best Genome!", "highlight");
        }
        evolution.bestGenome = {...best.genome};
      } else {
        log("Colony Failed. Retrying.", "danger");
      }

      evolution.generation++;
      setTimeout(startGeneration, 100);
    }

    // --- Logic Update ---

    function update(dt) {
      if (!state.active) return;
      state.genTimer += dt;
      globalTime += dt * 0.01;

      ui.timer.textContent = ((GEN_DURATION_MS - state.genTimer) / 1000).toFixed(1) + 's';
      if (state.genTimer >= GEN_DURATION_MS) endGeneration();

      // Flies (Z-Axis Logic)
      const chance = 1 - Math.pow(1 - flyRate, dt / 16);
      if (Math.random() < chance) {
        attemptFlyCross();
      }

      // Agents
      let activeCount = 0;
      let totalE = 0;
      state.agents.forEach(a => {
        if (!a.alive) return;
        activeCount++;
        totalE += a.energy;

        a.energy -= 0.05 * (dt / 16);
        if (a.energy <= 0) {a.alive = false; a.energy = 0; return;}

        if (a.state === 'crawling') updateCrawl(a, dt);
        else if (a.state === 'falling') updateFall(a, dt);
      });

      ui.pop.textContent = activeCount;
      let avgE = activeCount ? totalE / activeCount : 0;
      ui.bar.style.width = Math.min(100, (avgE / STARTING_ENERGY) * 100) + '%';
      ui.val.textContent = avgE.toFixed(0);

      if (activeCount === 0 && state.genTimer > 1000) endGeneration();
    }

    function attemptFlyCross() {
      const fx = Math.random() * state.width;
      const fy = Math.random() * state.height;

      state.agents.forEach(a => {
        if (!a.alive) return;
        let caught = false;

        for (let l of a.lines) {
          const d = distToSegment(fx, fy, l.x1, l.y1, l.x2, l.y2);
          if (d < 5) {
            caught = true;
            break;
          }
        }

        if (caught) {
          a.score++;
          a.energy += GAIN_FLY;
          a.fliesCaught.push({x: fx, y: fy});
          if (a.fliesCaught.length > 50) a.fliesCaught.shift();
        }
      });
    }

    function updateCrawl(a, dt) {
      const line = a.currentLineIdx < 4 ? state.frameLines[a.currentLineIdx] : a.lines[a.currentLineIdx - 4];

      if (!line) return;

      const len = Math.hypot(line.x2 - line.x1, line.y2 - line.y1);
      const speed = (2 + a.genome.speed * 2) * (dt / 16);
      const tStep = len > 0 ? speed / len : 0;

      a.t += tStep * a.direction;
      a.x = line.x1 + (line.x2 - line.x1) * a.t;
      a.y = line.y1 + (line.y2 - line.y1) * a.t;
      a.energy -= COST_CRAWL * speed;

      // Handle End of Line
      if (a.t <= 0 || a.t >= 1) {
        a.t = (a.t <= 0) ? 0 : 1;
        const px = (a.t === 0) ? line.x1 : line.x2;
        const py = (a.t === 0) ? line.y1 : line.y2;

        // Find connected lines (Frame + Private Web)
        const connected = [];
        // Check Frame
        state.frameLines.forEach((l, idx) => {
          if (idx === a.currentLineIdx) return;
          const d1 = Math.hypot(l.x1 - px, l.y1 - py);
          const d2 = Math.hypot(l.x2 - px, l.y2 - py);
          if (d1 < 1) connected.push({idx, startT: 0});
          else if (d2 < 1) connected.push({idx, startT: 1});
        });
        // Check Private Web
        a.lines.forEach((l, i) => {
          const realIdx = i + 4;
          if (realIdx === a.currentLineIdx) return;
          const d1 = Math.hypot(l.x1 - px, l.y1 - py);
          const d2 = Math.hypot(l.x2 - px, l.y2 - py);
          if (d1 < 1) connected.push({idx: realIdx, startT: 0});
          else if (d2 < 1) connected.push({idx: realIdx, startT: 1});
        });

        if (connected.length > 0) {
          const options = connected.map(c => {
            const l = c.idx < 4 ? state.frameLines[c.idx] : a.lines[c.idx - 4];
            const otherY = (c.startT === 0) ? l.y2 : l.y1;
            const isUp = otherY < a.y;
            return {...c, isUp};
          });

          const wantUp = Math.random() > a.genome.bias;
          const preferred = options.filter(o => o.isUp === wantUp);
          const candidates = preferred.length > 0 ? preferred : options;
          const next = candidates[Math.floor(Math.random() * candidates.length)];

          a.currentLineIdx = next.idx;
          a.t = next.startT;
          a.direction = (next.startT === 0) ? 1 : -1;
        } else {
          a.direction *= -1;
        }
      }

      // Decision: Drop
      const dropProb = 1 - Math.pow(1 - a.genome.dropRate, dt / 16);
      if (Math.random() < dropProb) {
        a.state = 'falling';
        a.dropStartPos = {x: a.x, y: a.y};
        a.vy = 2.0;
        a.vx = a.direction * (Math.random() * a.genome.glide);
        if (Math.random() < 0.2) a.vx *= -1;
        a.energy -= COST_DROP_START;
      }
    }

    function updateFall(a, dt) {
      const nextX = a.x + (a.vx * (dt / 16));
      const nextY = a.y + (a.vy * (dt / 16));

      a.energy -= COST_DROP_PIXEL * Math.hypot(a.vx, a.vy);

      // Check Collision with OWN lines + Frame (Parallel Reality)
      let hit = null;
      let minT = Infinity;

      const checkList = (list, offsetIdx) => {
        for (let i = 0; i < list.length; i++) {
          const l = list[i];
          const result = getIntersection(a.x, a.y, nextX, nextY, l.x1, l.y1, l.x2, l.y2);
          if (result) {
            const distFromStart = Math.hypot(result.x - a.dropStartPos.x, result.y - a.dropStartPos.y);
            if (distFromStart > 2) {
              const distToHit = Math.hypot(result.x - a.x, result.y - a.y);
              if (distToHit < minT) {
                minT = distToHit;
                hit = {idx: i + offsetIdx, x: result.x, y: result.y};
              }
            }
          }
        }
      };

      checkList(state.frameLines, 0);
      checkList(a.lines, 4);

      if (!hit) {
        if (nextY >= state.height) hit = {idx: 2, x: nextX, y: state.height}; // Bottom
        else if (nextX <= 0) hit = {idx: 3, x: 0, y: nextY}; // Left
        else if (nextX >= state.width) hit = {idx: 1, x: state.width, y: nextY}; // Right
      }

      if (hit) {
        // Landed!
        // CONSTRAINT: No Same-Side Frame Connections
        const startIsFrame = a.currentLineIdx < 4;
        const endIsFrame = hit.idx < 4;
        const sameSide = startIsFrame && endIsFrame && (a.currentLineIdx === hit.idx);

        if (!sameSide) {
          a.lines.push({
            x1: a.dropStartPos.x,
            y1: a.dropStartPos.y,
            x2: hit.x,
            y2: hit.y,
            id: a.lines.length,
            color: a.webColor
          });
        }

        a.state = 'crawling';
        a.x = hit.x;
        a.y = hit.y;
        a.currentLineIdx = hit.idx;

        const l = hit.idx < 4 ? state.frameLines[hit.idx] : a.lines[hit.idx - 4];
        const len = Math.hypot(l.x2 - l.x1, l.y2 - l.y1);
        const dist = Math.hypot(a.x - l.x1, a.y - l.y1);
        a.t = (len > 0) ? dist / len : 0;
        a.direction = Math.random() < 0.5 ? 1 : -1;
      } else {
        a.x = nextX;
        a.y = nextY;
      }
    }

    // --- Helpers ---
    function getIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
      const det = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3);
      if (det === 0) return null;
      const lambda = ((y4 - y3) * (x4 - x1) + (x3 - x4) * (y4 - y1)) / det;
      const gamma = ((y1 - y2) * (x4 - x1) + (x2 - x1) * (y4 - y1)) / det;
      if ((0 <= lambda && lambda <= 1) && (0 <= gamma && gamma <= 1)) {
        return {
          x: x1 + lambda * (x2 - x1),
          y: y1 + lambda * (y2 - y1)
        };
      }
      return null;
    }

    function distToSegment(x, y, x1, y1, x2, y2) {
      const A = x - x1, B = y - y1, C = x2 - x1, D = y2 - y1;
      const dot = A * C + B * D;
      const len_sq = C * C + D * D;
      let param = -1;
      if (len_sq != 0) param = dot / len_sq;
      let xx, yy;
      if (param < 0) {xx = x1; yy = y1;}
      else if (param > 1) {xx = x2; yy = y2;}
      else {xx = x1 + param * C; yy = y1 + param * D;}
      const dx = x - xx, dy = y - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // --- Render ---
    function loop(timestamp) {
      let steps = 1;
      if (simSpeed >= 10) steps = 5;
      if (simSpeed >= 100) steps = 20;
      if (simSpeed >= 1000) steps = 50;
      if (simSpeed >= 10000) steps = 100;

      const dt = (16 * simSpeed) / steps;

      for (let i = 0; i < steps; i++) {
        update(dt);
      }

      draw();
      requestAnimationFrame(loop);
    }

    function draw() {
      ctx.fillStyle = '#050510';
      ctx.fillRect(0, 0, state.width, state.height);

      // Draw Frame
      ctx.lineWidth = 2;
      state.frameLines.forEach(l => {
        ctx.beginPath();
        ctx.moveTo(l.x1, l.y1);
        ctx.lineTo(l.x2, l.y2);
        ctx.strokeStyle = '#333';
        ctx.stroke();
      });

      // Draw Agents and their Private Worlds
      state.agents.forEach(a => {
        if (!a.alive) return;

        // Web
        ctx.lineWidth = 1;
        a.lines.forEach(l => {
          ctx.beginPath();
          ctx.moveTo(l.x1, l.y1);
          ctx.lineTo(l.x2, l.y2);
          ctx.strokeStyle = l.color;
          ctx.stroke();
        });

        // Caught Flies
        ctx.fillStyle = '#ffaa00';
        a.fliesCaught.forEach(f => {
          ctx.beginPath(); ctx.arc(f.x, f.y, 1.5, 0, Math.PI * 2); ctx.fill();
        });

        // Dragline
        if (a.state === 'falling') {
          ctx.strokeStyle = a.webColor;
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.5;
          ctx.beginPath(); ctx.moveTo(a.dropStartPos.x, a.dropStartPos.y);
          ctx.lineTo(a.x, a.y); ctx.stroke();
          ctx.globalAlpha = 1;
          ctx.lineWidth = 1;
        }

        // Body
        ctx.save();
        ctx.translate(a.x, a.y);
        if (a.state === 'crawling') {
          const l = a.currentLineIdx < 4 ? state.frameLines[a.currentLineIdx] : a.lines[a.currentLineIdx - 4];
          if (l) {
            const ang = Math.atan2(l.y2 - l.y1, l.x2 - l.x1);
            ctx.rotate(ang);
          }
        } else {
          const ang = Math.atan2(a.vy, a.vx);
          ctx.rotate(ang);
        }

        ctx.fillStyle = a.color;
        ctx.beginPath(); ctx.ellipse(0, 0, 6, 3, 0, 0, Math.PI * 2); ctx.fill();

        ctx.strokeStyle = a.color;
        if (a.alive) {
          const wiggle = Math.sin(globalTime * 10 + a.legPhase) * 2;
          for (let i = -1; i <= 1; i += 2) {
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-5 * i, -8 + wiggle); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(5 * i, -8 - wiggle); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-8 * i, 8 + wiggle); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(8 * i, 8 - wiggle); ctx.stroke();
          }
        }
        ctx.restore();
      });
    }

    init();
  </script>
</body>

</html>
